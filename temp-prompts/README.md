# 一時的なプロンプト保存ディレクトリ

このディレクトリは、AIアシスタント（Cursor等）に対する一時的な指示やプロンプトを保存するための場所です。

## 使用目的
- 長文の指示や複雑なプロンプトの一時的な保存
- 複数のAIアシスタントセッションで再利用したい指示の保存
- 作業中のタスクに関する一時的なメモや指示の保管

## このファイルを利用した指示の仕方

```
次のファイルに従ってタスクを進めて欲しい。
temp-prompts/20240323_pokemon_quiz_system_implementation.md

その前に次のディレクトリの配下のルールファイルを読んで。軽くファイルを確認するのではなく、1ファイルずつ開いて読んで内容を覚えて。
docs/ai_guideline
```

## タスクファイルの作成プロセス

### 1. 実装アウトラインの作成と合意
1. **アウトラインの作成方針**
   ```
   a. ユーザーストーリーベース
      - 機能ではなくユーザーの行動フローに注目
      - 最小限の機能で実現できる範囲を特定
      - 段階的な拡張ポイントの識別
   
   b. 技術的な実現方法
      - 各ステップでの技術要素の特定
      - データの流れの把握
      - 必要なインフラの特定
   
   c. 制約条件の明確化
      - パフォーマンス要件
      - セキュリティ要件
      - 運用要件
   ```

2. **合意形成のプロセス**
   ```
   a. アウトラインのレビュー
      - 技術的な実現可能性
      - ビジネス要件との整合性
      - リスクの評価
   
   b. フィードバックの収集と反映
      - 懸念点の特定と対応
      - 追加要件の確認と組み込み
      - 優先順位の調整
   ```

### 2. フェーズ分割と優先順位付け
1. **分割基準**
   ```
   a. 独立したユーザーストーリー
      - 最小限の機能での実現可能性
      - 他機能への依存度
      - フィードバックの早期獲得
   
   b. 技術的な独立性
      - 共通基盤との関係
      - テスト容易性
      - リスク管理
   ```

2. **優先順位付けの基準**
   ```
   a. ビジネス価値
      - ユーザー価値の提供
      - 重要度と緊急度
   
   b. 技術的な考慮
      - 基盤となる機能の優先
      - リスクの早期検証
   ```

## タスク分解の具体的な指針

### 1. フェーズ内の分割方針
1. **独立したユーザーストーリーへの分割**
   ```
   例：ルーム作成機能の場合
   A: ルーム作成の基本機能
   B: 参加者作成の基本機能
   C: ルーム参加の基本機能
   ```

2. **各機能の実装レイヤー**
   ```
   a. ドメインモジュール
      - Command（副作用のある処理）
      - Query（参照系の処理）
      - テストファースト

   b. API層
      - エンドポイント定義
      - バリデーション
      - テストファースト

   c. フロントエンド層
      - コンポーネント実装
      - テストファースト

   d. E2E
      - フロー全体のテスト
      - 調整・修正
   ```

### 2. タスクの記述方法
1. **具体的なアクション**
   ```
   悪い例：
   - APIの実装
   
   良い例：
   1. POST /api/endpoint のテスト作成
   2. エンドポイントの実装
      - リクエストバリデーション
      - レスポンス形式の定義
   ```

2. **テストファーストの明示**
   ```
   - 各実装タスクの前にテスト作成を明記
   - テストの詳細は実装時に検討
   ```

### 3. 分解時の注意点
- 各サブフェーズは独立して実装・テスト可能であること
- ドメインモジュールは責務を明確に分離すること
- CommandとQueryを明確に分けること
- フロントエンドは最小限のUIから始めること

### 4. タスク列挙とサイクル管理の注意点
1. **レイヤー分割とサイクル管理のバランス**
   ```
   a. レイヤー分割のメリット
      - タスクの整理がしやすい
      - 責務の範囲が明確
      - レビューがしやすい
   
   b. レイヤー分割による罠
      - レイヤーごとに実装を進めようとする誘惑
      - 小さなサイクルでの価値提供が遅れる
      - フィードバックループが長くなる
   ```

2. **推奨されるアプローチ**
   ```
   a. 機能サイクルベースの実装
      - 1つの機能を小さく切り出し
      - 必要な全レイヤーを含めて実装
      - 早期のフィードバック獲得
   
   b. レイヤー分割の活用
      - タスクの整理・可視化の手段として使用
      - 実装順序を縛るものとしない
      - チェックリストとしての利用
   ```

3. **具体例**
   ```
   悪い例（レイヤー順実装）：
   1. ドメインモジュールを全て実装
   2. API層を全て実装
   3. フロントエンド層を全て実装
   
   良い例（機能サイクル実装）：
   1. 機能Aの最小実装
      - 必要なドメインロジック
      - 必要なAPI
      - 必要なUI
   2. 機能Bの最小実装
      - 必要なドメインロジック
      - 必要なAPI
      - 必要なUI
   ```

## プロンプトファイルの構成

### 1. プロジェクトの背景
- システムの目的と概要
- 技術選定の理由と制約
- 重要な要件や制限事項

### 2. 実装アウトライン
- ユーザーストーリーベースの機能整理
- 技術的な実現方法
- 制約条件の整理

### 3. フェーズ分割
- 独立したユーザーストーリーへの分割
- 各フェーズの目的と範囲
- フェーズ間の依存関係

### 4. タスク一覧
- フェーズごとのタスク
  - ドメインモジュール（Command/Query）
  - API層
  - フロントエンド層
  - E2Eテスト
- テストファーストの明示

### 5. 進捗管理
- 完了したタスクのチェック
- 現在の作業状況
- 次のステップ
- 発生した課題

## フェーズの設計と優先順位付け

### 1. フェーズの分割方針
1. **コアフローの特定**
   - ユーザーの主要なストーリーを特定
   - 最小限の機能で完結するフローを定義
   - 依存関係の分析

2. **機能の分類**
   ```
   a. コア機能（必須）
      - システムの根幹となる機能
      - 他の機能の前提となるもの
      - ユーザー価値の中核となるもの
   
   b. 拡張機能（付加価値）
      - コア機能を補完するもの
      - UX向上のための機能
      - 運用効率化のための機能
   
   c. 運用機能（管理/監視）
      - システム管理に必要な機能
      - モニタリング機能
      - メンテナンス機能
   ```

3. **依存関係の分析**
   ```
   a. 技術的依存
      - データモデル間の関係
      - API間の依存関係
      - 共通コンポーネントの依存関係
   
   b. 機能的依存
      - ユーザーフロー上の依存
      - ビジネスロジック上の依存
      - データフロー上の依存
   ```

### 2. フェーズの優先順位付け
1. **優先度の判断基準**
   ```
   a. 技術的な基準
      - 他機能への影響度
      - 技術的な複雑さ
      - リスクの大きさ
   
   b. ビジネス的な基準
      - ユーザー価値
      - ビジネスインパクト
      - 市場の要求
   
   c. 実装効率の基準
      - 開発工数
      - チームの習熟度
      - 再利用可能性
   ```

2. **フェーズの実装順序**
   ```
   1. 基盤フェーズ
      - データモデルの核となる部分
      - 認証・認可の基本機能
      - 共通コンポーネント
   
   2. コア機能フェーズ
      - ユーザーストーリーの核となる機能
      - 最小限の機能セット
      - 基本的なユーザーフロー
   
   3. 拡張機能フェーズ
      - UX向上のための機能
      - 追加的なユースケース
      - パフォーマンス最適化
   
   4. 運用機能フェーズ
      - 管理機能
      - モニタリング機能
      - メンテナンス機能
   ```

3. **マイルストーン設定**
   ```
   a. 技術検証フェーズ
      - アーキテクチャの検証
      - 主要な技術要素の検証
      - パフォーマンスの検証
   
   b. MVP（最小実用製品）フェーズ
      - コア機能の実装
      - 基本的なユーザーフロー
      - 最小限のUI/UX
   
   c. 製品化フェーズ
      - 拡張機能の実装
      - UI/UXの改善
      - パフォーマンスチューニング
   
   d. 運用フェーズ
      - 運用機能の実装
      - モニタリングの整備
      - 保守性の向上
   ```

### 3. フェーズ間の移行基準
- 全てのテストが成功していること
- コードレビューが完了していること
- ドキュメントが更新されていること
- パフォーマンス要件を満たしていること
- セキュリティ要件を満たしていること

このアプローチにより：
- 効率的なリソース配分
- リスクの早期発見と対応
- 段階的な価値の提供
- 柔軟な計画の調整
が可能になります。

## タスクの実行プロセス

### 1. タスク着手前の宣言
1. **実行内容の提示**
   ```
   - 着手するタスクの明確化
   - 実装方針の説明
   - 想定される結果の提示
   ```

2. **必要に応じた詳細化**
   ```
   - タスクの細分化
   - 具体的な実装ステップの提示
   - 追加で必要な考慮事項の説明
   ```

3. **合意形成**
   ```
   - 提案内容のレビュー
   - 必要な調整の実施
   - 実装開始の承認
   ```

### 2. テスト駆動開発の徹底
1. **テストファーストの原則**
   ```
   - タスク開始時にテストを作成
   - 失敗するテストの確認
   - テストが示す仕様の確認
   ```

2. **実装サイクル**
   ```
   a. テストの作成
      - 修正意図に沿ったテストを作成
      - テストは具体的なシナリオを記述
      - テストは独立して実行可能

   b. 実装の作成/修正
      - テストを通すための最小限の実装
      - テストの意図に沿った実装
      - コードの品質を維持

   c. テストの実行
      - テストを実行して結果を確認
      - 成功した場合：次のステップに進む
      - 失敗した場合：
        - エラーを分析
        - 実装を修正
        - cに戻る

   d. 次のサイクルへ
      - aに戻って次のテストケースの作成
      - 全てのテストケースが成功するまで繰り返す
   ```

3. **テスト完了の定義**
   ```
   - 作成した全てのテストが成功
   - エッジケースの考慮
   - テストカバレッジの確認
   ```

### 3. 作業完了の定義
- 全てのテストが成功していること
- コードレビューが完了していること
- 実装が承認されていること
- ドキュメントが更新されていること

### 4. テスト実行とコマンド実行のルール
1. **テスト実行**
   ```
   - テストは必ず実行環境に依存するため、Dockerコンテナ内で実行
   - 例: docker exec pokemon-shitteru-app-1 npm test
   - テスト実行前に必ずコンテナが起動していることを確認
   ```

2. **Prisma関連のコマンド**
   ```
   - Prismaのコマンドはpackage.jsonに定義されたスクリプトを使用
   - コマンドはDockerコンテナ内で実行
   - 例: docker exec pokemon-shitteru-app-1 npm run prisma:generate
   ```

3. **コマンド実行の原則**
   ```
   - 環境依存のコマンドは必ずDockerコンテナ内で実行
   - コンテナ名はdocker-compose.ymlで定義されたものを使用
   - コマンド実行前にコンテナの状態を確認
   - npm install実行後、または`sh: 1: vitest: not found`エラーが発生した場合
      - 以下のコマンドを実行してコンテナを再起動
      - docker compose restart && sleep 5
      - 再起動後すぐは同じエラーが出る可能性があるため、sleepを入れる
   ```

### 5. タスク完了時の更新ルール
1. **タスクファイルの更新**
   ```
   a. 完了したタスクのマーク
      - [ ] から [x] に変更
      - 完了したタスクの日付を記録
   
   b. 触ったファイルの記録
      - 直近触ったファイルセクションに追加
      - ファイルパスを正確に記録
      - 関連する依存ファイルも含める
   ```

2. **更新のタイミング**
   ```
   - タスク完了時に即時更新
   - テスト成功後に更新
   - コードレビュー完了後に更新
   ```

3. **更新の確認**
   ```
   - タスクの完了状態
   - 触ったファイルの一覧
   - 次のステップの明確化
   ```

このアプローチにより：
- 意図した実装の確実な実現
- 品質の確保
- スムーズな進行
が可能になります。

## 注意事項
- このディレクトリ内のマークダウンファイル（`*.md`）は`.gitignore`によってGit管理から除外されます
- `README.md`のみGit管理対象となります
- ドメイン知識や永続的に保存したい情報は`docs/`ディレクトリに保存してください 